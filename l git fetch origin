[1mdiff --git a/bot/src/config.py b/bot/src/config.py[m
[1mindex 9f17b7e7..bce1863f 100644[m
[1m--- a/bot/src/config.py[m
[1m+++ b/bot/src/config.py[m
[36m@@ -13,7 +13,11 @@[m [mclass Settings(BaseSettings):[m
     # API[m
     API_BASE_URL: str = "http://api:8000"[m
     API_V1_STR: str = "/api/v1"[m
[31m-    [m
[32m+[m
[32m+[m[32m    # Storage[m
[32m+[m[32m    AUDIO_STORAGE_PATH: str = "audio_files"[m
[32m+[m[32m    MAX_AUDIO_FILE_SIZE_MB: int = 10[m
[32m+[m
     # Frontend[m
     FRONTEND_URL: str = "http://localhost:4444"[m
     # Feature flag: activer les boutons inline (HTTPS requis). Si false, fallback texte cliquable[m
[1mdiff --git a/bot/src/handlers/depot.py b/bot/src/handlers/depot.py[m
[1mindex c34cc414..702b84c3 100644[m
[1m--- a/bot/src/handlers/depot.py[m
[1m+++ b/bot/src/handlers/depot.py[m
[36m@@ -7,7 +7,7 @@[m [mimport asyncio[m
 import logging[m
 import os[m
 from datetime import datetime, timedelta[m
[31m-from typing import Dict, Any[m
[32m+[m[32mfrom typing import Dict, Any, Optional[m
 import httpx[m
 from telegram import Update[m
 from telegram.ext import ([m
[36m@@ -18,6 +18,7 @@[m [mfrom telegram.ext import ([m
     filters[m
 )[m
 from ..config import settings[m
[32m+[m[32mfrom ..services.user_service import user_service[m
 from .validation import send_validation_message[m
 [m
 logger = logging.getLogger(__name__)[m
[36m@@ -28,6 +29,19 @@[m [mWAITING_FOR_AUDIO = 1[m
 # Session timeout (5 minutes as per story requirements)[m
 SESSION_TIMEOUT = 300  # 5 minutes in seconds[m
 [m
[32m+[m[32m# Audio configuration[m
[32m+[m[32mSUPPORTED_AUDIO_MIME_TYPES = {[m
[32m+[m[32m    "audio/ogg": ".ogg",[m
[32m+[m[32m    "audio/oga": ".ogg",[m
[32m+[m[32m    "audio/webm": ".ogg",[m
[32m+[m[32m    "audio/mpeg": ".mp3",[m
[32m+[m[32m    "audio/mp3": ".mp3",[m
[32m+[m[32m    "audio/wav": ".wav",[m
[32m+[m[32m    "audio/x-wav": ".wav",[m
[32m+[m[32m}[m
[32m+[m[32mSUPPORTED_AUDIO_EXTENSIONS = {".ogg", ".oga", ".mp3", ".wav"}[m
[32m+[m[32mMAX_AUDIO_FILE_SIZE_BYTES = settings.MAX_AUDIO_FILE_SIZE_MB * 1024 * 1024[m
[32m+[m
 # In-memory storage for active sessions (in production, use Redis)[m
 active_sessions: Dict[int, Dict[str, Any]] = {}[m
 [m
[36m@@ -39,7 +53,32 @@[m [masync def start_depot_session(update: Update, context: ContextTypes.DEFAULT_TYPE[m
     user_id = update.effective_user.id[m
     username = update.effective_user.username or update.effective_user.first_name[m
 [m
[31m-    logger.info(f"User {username} ({user_id}) started depot session")[m
[32m+[m[32m    logger.info(f"User {username} ({user_id}) requested depot session")[m
[32m+[m
[32m+[m[32m    # Validate user authorization via API[m
[32m+[m[32m    try:[m
[32m+[m[32m        user_record = await user_service.get_user_by_telegram_id(str(user_id))[m
[32m+[m[32m    except Exception as exc:[m
[32m+[m[32m        logger.error("Failed to verify Telegram user %s authorization: %s", user_id, exc)[m
[32m+[m[32m        user_record = None[m
[32m+[m
[32m+[m[32m    if not user_record:[m
[32m+[m[32m        await update.message.reply_text([m
[32m+[m[32m            "‚ùå Vous n'√™tes pas autoris√© √† enregistrer un d√©p√¥t pour le moment.\n"[m
[32m+[m[32m            "Utilisez /inscription pour demander l'acc√®s ou contactez un administrateur."[m
[32m+[m[32m        )[m
[32m+[m[32m        return ConversationHandler.END[m
[32m+[m
[32m+[m[32m    status = (user_record.get("status") or "").lower()[m
[32m+[m[32m    is_active = bool(user_record.get("is_active", False))[m
[32m+[m[32m    allowed_statuses = {"approved", "active"}[m
[32m+[m
[32m+[m[32m    if not is_active or (status and status not in allowed_statuses):[m
[32m+[m[32m        await update.message.reply_text([m
[32m+[m[32m            "‚è≥ Votre compte est en attente d'activation par un administrateur.\n"[m
[32m+[m[32m            "Vous recevrez une notification d√®s qu'il sera valid√©."[m
[32m+[m[32m        )[m
[32m+[m[32m        return ConversationHandler.END[m
 [m
     # Check if user already has an active session[m
     if user_id in active_sessions:[m
[36m@@ -71,7 +110,7 @@[m [masync def start_depot_session(update: Update, context: ContextTypes.DEFAULT_TYPE[m
         "üìã **Instructions :**\n"[m
         "‚Ä¢ D√©crivez clairement l'objet\n"[m
         "‚Ä¢ Mentionnez le type (√©lectrom√©nager, informatique, etc.)\n"[m
[31m-        "‚Ä¢ Formats support√©s : audio vocal Telegram\n\n"[m
[32m+[m[32m        "‚Ä¢ Formats support√©s : OGG, MP3, WAV\n\n"[m
         "‚è±Ô∏è Session expire dans 5 minutes\n"[m
         "‚ùå Tapez /annuler pour arr√™ter",[m
         parse_mode='Markdown'[m
[36m@@ -96,6 +135,30 @@[m [masync def handle_voice_message(update: Update, context: ContextTypes.DEFAULT_TYP[m
     session = active_sessions[user_id][m
     logger.info(f"Processing voice message for user {session['username']} ({user_id})")[m
 [m
[32m+[m[32m    telegram_audio, file_id, mime_type, file_size, original_file_name = _extract_audio_metadata(update)[m
[32m+[m
[32m+[m[32m    if not telegram_audio or not file_id:[m
[32m+[m[32m        await update.message.reply_text([m
[32m+[m[32m            "‚ùå Impossible de lire ce message audio. Veuillez r√©essayer."[m
[32m+[m[32m        )[m
[32m+[m[32m        return WAITING_FOR_AUDIO[m
[32m+[m
[32m+[m[32m    file_extension = _resolve_audio_extension(mime_type, original_file_name)[m
[32m+[m
[32m+[m[32m    if not file_extension:[m
[32m+[m[32m        await update.message.reply_text([m
[32m+[m[32m            "‚ùå Format audio non support√©. Formats accept√©s : OGG, MP3, WAV."[m
[32m+[m[32m        )[m
[32m+[m[32m        return WAITING_FOR_AUDIO[m
[32m+[m
[32m+[m[32m    if file_size and file_size > MAX_AUDIO_FILE_SIZE_BYTES:[m
[32m+[m[32m        max_size = settings.MAX_AUDIO_FILE_SIZE_MB[m
[32m+[m[32m        await update.message.reply_text([m
[32m+[m[32m            "‚ùå Fichier trop volumineux.\n"[m
[32m+[m[32m            f"La taille maximale autoris√©e est de {max_size} Mo."[m
[32m+[m[32m        )[m
[32m+[m[32m        return WAITING_FOR_AUDIO[m
[32m+[m
     try:[m
         # Send processing message[m
         processing_msg = await update.message.reply_text([m
[36m@@ -103,17 +166,15 @@[m [masync def handle_voice_message(update: Update, context: ContextTypes.DEFAULT_TYP[m
             "‚è≥ T√©l√©chargement et analyse en cours..."[m
         )[m
 [m
[31m-        # Download voice file[m
[31m-        voice = update.message.voice[m
[31m-        file = await context.bot.get_file(voice.file_id)[m
[32m+[m[32m        file = await context.bot.get_file(file_id)[m
 [m
         # Create audio directory if it doesn't exist[m
[31m-        audio_dir = "audio_files"[m
[32m+[m[32m        audio_dir = settings.AUDIO_STORAGE_PATH[m
         os.makedirs(audio_dir, exist_ok=True)[m
 [m
         # Generate unique filename[m
         timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")[m
[31m-        filename = f"deposit_{user_id}_{timestamp}.ogg"[m
[32m+[m[32m        filename = f"deposit_{user_id}_{timestamp}{file_extension}"[m
         file_path = os.path.join(audio_dir, filename)[m
 [m
         # Download file[m
[36m@@ -202,13 +263,43 @@[m [masync def handle_invalid_message(update: Update, context: ContextTypes.DEFAULT_T[m
     )[m
     return WAITING_FOR_AUDIO[m
 [m
[32m+[m[32mdef _extract_audio_metadata(update: Update) -> tuple[Optional[Any], Optional[str], str, int, Optional[str]]:[m
[32m+[m[32m    """Extract audio metadata from update message."""[m
[32m+[m[32m    message = update.message[m
[32m+[m
[32m+[m[32m    if message.voice:[m
[32m+[m[32m        voice = message.voice[m
[32m+[m[32m        mime_type = (voice.mime_type or "audio/ogg").lower()[m
[32m+[m[32m        return voice, voice.file_id, mime_type, voice.file_size or 0, None[m
[32m+[m
[32m+[m[32m    if message.audio:[m
[32m+[m[32m        audio = message.audio[m
[32m+[m[32m        mime_type = (audio.mime_type or "").lower()[m
[32m+[m[32m        return audio, audio.file_id, mime_type, audio.file_size or 0, audio.file_name[m
[32m+[m
[32m+[m[32m    return None, None, "", 0, None[m
[32m+[m
[32m+[m[32mdef _resolve_audio_extension(mime_type: str, file_name: Optional[str]) -> Optional[str]:[m
[32m+[m[32m    """Determine the appropriate file extension for the audio payload."""[m
[32m+[m[32m    if file_name:[m
[32m+[m[32m        _, ext = os.path.splitext(file_name)[m
[32m+[m[32m        ext = ext.lower()[m
[32m+[m[32m        if ext in SUPPORTED_AUDIO_EXTENSIONS:[m
[32m+[m[32m            return ext[m
[32m+[m
[32m+[m[32m    normalized_mime = (mime_type or "").lower()[m
[32m+[m[32m    if normalized_mime in SUPPORTED_AUDIO_MIME_TYPES:[m
[32m+[m[32m        return SUPPORTED_AUDIO_MIME_TYPES[normalized_mime][m
[32m+[m
[32m+[m[32m    return None[m
[32m+[m
 async def _handle_session_timeout(user_id: int, update: Update, context: ContextTypes.DEFAULT_TYPE):[m
     """Handle session timeout after 5 minutes."""[m
     await asyncio.sleep(SESSION_TIMEOUT)[m
 [m
     if user_id in active_sessions:[m
         logger.info(f"Session timeout for user {user_id}")[m
[31m-        await _cleanup_session(user_id)[m
[32m+[m[32m        await _cleanup_session(user_id, cancel_timeout=False)[m
 [m
         # Try to send timeout message[m
         try:[m
[36m@@ -222,14 +313,22 @@[m [masync def _handle_session_timeout(user_id: int, update: Update, context: Context[m
         except Exception as e:[m
             logger.error(f"Could not send timeout message to user {user_id}: {e}")[m
 [m
[31m-async def _cleanup_session(user_id: int):[m
[32m+[m[32masync def _cleanup_session(user_id: int, *, cancel_timeout: bool = True):[m
     """Clean up user session and cancel timeout task."""[m
     if user_id in active_sessions:[m
         session = active_sessions[user_id][m
 [m
         # Cancel timeout task if exists[m
[31m-        if session.get('timeout_task'):[m
[31m-            session['timeout_task'].cancel()[m
[32m+[m[32m        if cancel_timeout and session.get('timeout_task'):[m
[32m+[m[32m            timeout_task = session['timeout_task'][m
[32m+[m[32m            try:[m
[32m+[m[32m                timeout_task.cancel()[m
[32m+[m[32m            except Exception as exc:[m
[32m+[m[32m                logger.debug([m
[32m+[m[32m                    "Could not cancel timeout task for user %s: %s",[m
[32m+[m[32m                    user_id,[m
[32m+[m[32m                    exc,[m
[32m+[m[32m                )[m
 [m
         # Remove from active sessions[m
         del active_sessions[user_id][m
[36m@@ -347,7 +446,7 @@[m [mdepot_conversation_handler = ConversationHandler([m
     entry_points=[CommandHandler("depot", start_depot_session)],[m
     states={[m
         WAITING_FOR_AUDIO: [[m
[31m-            MessageHandler(filters.VOICE, handle_voice_message),[m
[32m+[m[32m            MessageHandler(filters.VOICE | filters.AUDIO, handle_voice_message),[m
             MessageHandler(filters.TEXT & ~filters.COMMAND, handle_invalid_message),[m
             CommandHandler("annuler", cancel_depot_session),[m
         ],[m
[1mdiff --git a/bot/tests/test_depot_handler.py b/bot/tests/test_depot_handler.py[m
[1mindex c7f92c96..8b9e6712 100644[m
[1m--- a/bot/tests/test_depot_handler.py[m
[1m+++ b/bot/tests/test_depot_handler.py[m
[36m@@ -5,9 +5,10 @@[m [mTests the /depot command, voice message handling, and session management.[m
 [m
 import pytest[m
 import asyncio[m
[32m+[m[32mfrom datetime import datetime[m
 from unittest.mock import AsyncMock, MagicMock, patch[m
[31m-from telegram import Update, Message, User, Chat, Voice[m
[31m-from telegram.ext import ContextTypes[m
[32m+[m[32mfrom telegram import Update, Message, User, Chat, Voice, Audio[m
[32m+[m[32mfrom telegram.ext import ContextTypes, ConversationHandler[m
 [m
 from bot.src.handlers.depot import ([m
     start_depot_session,[m
[36m@@ -15,7 +16,9 @@[m [mfrom bot.src.handlers.depot import ([m
     cancel_depot_session,[m
     handle_invalid_message,[m
     active_sessions,[m
[31m-    WAITING_FOR_AUDIO[m
[32m+[m[32m    WAITING_FOR_AUDIO,[m
[32m+[m[32m    _handle_session_timeout,[m
[32m+[m[32m    SESSION_TIMEOUT,[m
 )[m
 [m
 [m
[36m@@ -30,6 +33,8 @@[m [mdef mock_update():[m
 [m
     update.message = MagicMock(spec=Message)[m
     update.message.reply_text = AsyncMock()[m
[32m+[m[32m    update.message.voice = None[m
[32m+[m[32m    update.message.audio = None[m
 [m
     return update[m
 [m
[36m@@ -49,6 +54,8 @@[m [mdef mock_voice_message(mock_update):[m
     """Create a mock voice message."""[m
     mock_update.message.voice = MagicMock(spec=Voice)[m
     mock_update.message.voice.file_id = "test_file_id"[m
[32m+[m[32m    mock_update.message.voice.mime_type = "audio/ogg"[m
[32m+[m[32m    mock_update.message.voice.file_size = 1024[m
 [m
     # Mock file object[m
     mock_file = MagicMock()[m
[36m@@ -63,6 +70,21 @@[m [mclass TestDepotHandler:[m
     def setup_method(self):[m
         """Clean up active sessions before each test."""[m
         active_sessions.clear()[m
[32m+[m[32m        patcher = patch([m
[32m+[m[32m            "bot.src.handlers.depot.user_service.get_user_by_telegram_id",[m
[32m+[m[32m            new_callable=AsyncMock,[m
[32m+[m[32m        )[m
[32m+[m[32m        self.user_service_patcher = patcher[m
[32m+[m[32m        self.mock_user_service = patcher.start()[m
[32m+[m[32m        self.mock_user_service.return_value = {[m
[32m+[m[32m            "id": "user-123",[m
[32m+[m[32m            "is_active": True,[m
[32m+[m[32m            "status": "approved",[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m    def teardown_method(self):[m
[32m+[m[32m        active_sessions.clear()[m
[32m+[m[32m        self.user_service_patcher.stop()[m
 [m
     @pytest.mark.asyncio[m
     async def test_start_depot_session_new_user(self, mock_update, mock_context):[m
[36m@@ -72,6 +94,9 @@[m [mclass TestDepotHandler:[m
         # Check return value[m
         assert result == WAITING_FOR_AUDIO[m
 [m
[32m+[m[32m        # Check authorization lookup[m
[32m+[m[32m        self.mock_user_service.assert_awaited_once_with(str(mock_update.effective_user.id))[m
[32m+[m
         # Check session was created[m
         user_id = mock_update.effective_user.id[m
         assert user_id in active_sessions[m
[36m@@ -107,6 +132,36 @@[m [mclass TestDepotHandler:[m
         call_args = mock_update.message.reply_text.call_args[0][0][m
         assert "session de d√©p√¥t active" in call_args[m
 [m
[32m+[m[32m    @pytest.mark.asyncio[m
[32m+[m[32m    async def test_start_depot_session_unauthorized_user(self, mock_update, mock_context):[m
[32m+[m[32m        """Test that unauthorized users cannot start a session."""[m
[32m+[m[32m        self.mock_user_service.return_value = None[m
[32m+[m
[32m+[m[32m        result = await start_depot_session(mock_update, mock_context)[m
[32m+[m
[32m+[m[32m        assert result == ConversationHandler.END[m
[32m+[m[32m        mock_update.message.reply_text.assert_called_once()[m
[32m+[m[32m        message = mock_update.message.reply_text.call_args[0][0][m
[32m+[m[32m        assert "pas autoris√©" in message[m
[32m+[m[32m        assert mock_update.effective_user.id not in active_sessions[m
[32m+[m
[32m+[m[32m    @pytest.mark.asyncio[m
[32m+[m[32m    async def test_start_depot_session_pending_user(self, mock_update, mock_context):[m
[32m+[m[32m        """Test that pending users are asked to wait for activation."""[m
[32m+[m[32m        self.mock_user_service.return_value = {[m
[32m+[m[32m            "id": "user-123",[m
[32m+[m[32m            "is_active": True,[m
[32m+[m[32m            "status": "pending",[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        result = await start_depot_session(mock_update, mock_context)[m
[32m+[m
[32m+[m[32m        assert result == ConversationHandler.END[m
[32m+[m[32m        mock_update.message.reply_text.assert_called_once()[m
[32m+[m[32m        message = mock_update.message.reply_text.call_args[0][0][m
[32m+[m[32m        assert "en attente d'activation" in message[m
[32m+[m[32m        assert mock_update.effective_user.id not in active_sessions[m
[32m+[m
     @pytest.mark.asyncio[m
     async def test_cancel_depot_session_active(self, mock_update, mock_context):[m
         """Test canceling an active depot session."""[m
[36m@@ -206,6 +261,54 @@[m [mclass TestDepotHandler:[m
         # Check session was cleaned up[m
         assert user_id not in active_sessions[m
 [m
[32m+[m[32m    @pytest.mark.asyncio[m
[32m+[m[32m    async def test_handle_voice_message_file_too_large(self, mock_voice_message, mock_context):[m
[32m+[m[32m        """Voice message larger than allowed size should be rejected."""[m
[32m+[m[32m        mock_update, _ = mock_voice_message[m
[32m+[m[32m        user_id = mock_update.effective_user.id[m
[32m+[m
[32m+[m[32m        active_sessions[user_id] = {[m
[32m+[m[32m            'user_id': user_id,[m
[32m+[m[32m            'username': 'testuser',[m
[32m+[m[32m            'start_time': None,[m
[32m+[m[32m            'timeout_task': None[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        from bot.src.handlers.depot import MAX_AUDIO_FILE_SIZE_BYTES[m
[32m+[m
[32m+[m[32m        mock_update.message.voice.file_size = MAX_AUDIO_FILE_SIZE_BYTES + 1[m
[32m+[m
[32m+[m[32m        result = await handle_voice_message(mock_update, mock_context)[m
[32m+[m
[32m+[m[32m        assert result == WAITING_FOR_AUDIO[m
[32m+[m[32m        mock_update.message.reply_text.assert_called_once()[m
[32m+[m[32m        message = mock_update.message.reply_text.call_args[0][0][m
[32m+[m[32m        assert "Fichier trop volumineux" in message[m
[32m+[m[32m        assert user_id in active_sessions[m
[32m+[m
[32m+[m[32m    @pytest.mark.asyncio[m
[32m+[m[32m    async def test_handle_voice_message_unsupported_format(self, mock_voice_message, mock_context):[m
[32m+[m[32m        """Unsupported audio formats should prompt retry."""[m
[32m+[m[32m        mock_update, _ = mock_voice_message[m
[32m+[m[32m        user_id = mock_update.effective_user.id[m
[32m+[m
[32m+[m[32m        active_sessions[user_id] = {[m
[32m+[m[32m            'user_id': user_id,[m
[32m+[m[32m            'username': 'testuser',[m
[32m+[m[32m            'start_time': None,[m
[32m+[m[32m            'timeout_task': None[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        mock_update.message.voice.mime_type = "audio/flac"[m
[32m+[m
[32m+[m[32m        result = await handle_voice_message(mock_update, mock_context)[m
[32m+[m
[32m+[m[32m        assert result == WAITING_FOR_AUDIO[m
[32m+[m[32m        mock_update.message.reply_text.assert_called_once()[m
[32m+[m[32m        message = mock_update.message.reply_text.call_args[0][0][m
[32m+[m[32m        assert "Format audio non support√©" in message[m
[32m+[m[32m        assert user_id in active_sessions[m
[32m+[m
     @pytest.mark.asyncio[m
     @patch('bot.src.handlers.depot._send_to_api')[m
     async def test_handle_voice_message_api_failure([m
[36m@@ -258,6 +361,32 @@[m [mclass TestDepotHandler:[m
         call_args = mock_update.message.reply_text.call_args[0][0][m
         assert "Envoyez un message vocal" in call_args[m
 [m
[32m+[m[32m    @pytest.mark.asyncio[m
[32m+[m[32m    async def test_session_timeout_sends_expiration_message(self, mock_update, mock_context):[m
[32m+[m[32m        """Session timeout should notify user and preserve cleanup."""[m
[32m+[m[32m        user_id = mock_update.effective_user.id[m
[32m+[m[32m        timeout_task = MagicMock()[m
[32m+[m[32m        timeout_task.cancel = MagicMock()[m
[32m+[m
[32m+[m[32m        active_sessions[user_id] = {[m
[32m+[m[32m            'user_id': user_id,[m
[32m+[m[32m            'username': 'testuser',[m
[32m+[m[32m            'start_time': datetime.utcnow(),[m
[32m+[m[32m            'timeout_task': timeout_task,[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        with patch('bot.src.handlers.depot.asyncio.sleep', new_callable=AsyncMock) as sleep_mock:[m
[32m+[m[32m            sleep_mock.return_value = None[m
[32m+[m[32m            await _handle_session_timeout(user_id, mock_update, mock_context)[m
[32m+[m[32m            sleep_mock.assert_awaited_once_with(SESSION_TIMEOUT)[m
[32m+[m
[32m+[m[32m        assert user_id not in active_sessions[m
[32m+[m[32m        timeout_task.cancel.assert_not_called()[m
[32m+[m
[32m+[m[32m        mock_context.bot.send_message.assert_awaited_once()[m
[32m+[m[32m        _, kwargs = mock_context.bot.send_message.await_args[m
[32m+[m[32m        assert "Session de d√©p√¥t expir√©e" in kwargs['text'][m
[32m+[m
     @pytest.mark.asyncio[m
     @patch('httpx.AsyncClient')[m
     async def test_send_to_api_success(self, mock_client_class):[m
[36m@@ -331,6 +460,61 @@[m [mclass TestDepotHandler:[m
         assert result['category'] == 'IT_EQUIPMENT'[m
         assert result['confidence'] == 0.85[m
 [m
[32m+[m[32m    @pytest.mark.asyncio[m
[32m+[m[32m    @patch('bot.src.handlers.depot._send_to_api')[m
[32m+[m[32m    @patch('bot.src.handlers.depot._trigger_classification')[m
[32m+[m[32m    @patch('os.makedirs')[m
[32m+[m[32m    async def test_handle_audio_message_success([m
[32m+[m[32m        self,[m
[32m+[m[32m        mock_makedirs,[m
[32m+[m[32m        mock_classify,[m
[32m+[m[32m        mock_send_api,[m
[32m+[m[32m        mock_update,[m
[32m+[m[32m        mock_context[m
[32m+[m[32m    ):[m
[32m+[m[32m        """Test handling of standard audio files (mp3)."""[m
[32m+[m[32m        user_id = mock_update.effective_user.id[m
[32m+[m
[32m+[m[32m        active_sessions[user_id] = {[m
[32m+[m[32m            'user_id': user_id,[m
[32m+[m[32m            'username': 'testuser',[m
[32m+[m[32m            'start_time': None,[m
[32m+[m[32m            'timeout_task': None[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        mock_update.message.voice = None[m
[32m+[m[32m        mock_update.message.audio = MagicMock(spec=Audio)[m
[32m+[m[32m        mock_update.message.audio.file_id = "audio_file_id"[m
[32m+[m[32m        mock_update.message.audio.mime_type = "audio/mpeg"[m
[32m+[m[32m        mock_update.message.audio.file_size = 2048[m
[32m+[m[32m        mock_update.message.audio.file_name = "sample.mp3"[m
[32m+[m
[32m+[m[32m        mock_file = MagicMock()[m
[32m+[m[32m        mock_file.download_to_drive = AsyncMock()[m
[32m+[m[32m        mock_context.bot.get_file.return_value = mock_file[m
[32m+[m
[32m+[m[32m        mock_send_api.return_value = {[m
[32m+[m[32m            'success': True,[m
[32m+[m[32m            'deposit_id': 'test-audio-789'[m
[32m+[m[32m        }[m
[32m+[m[32m        mock_classify.return_value = {[m
[32m+[m[32m            'success': True,[m
[32m+[m[32m            'category': 'IT_EQUIPMENT',[m
[32m+[m[32m            'confidence': 0.9[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        processing_msg = MagicMock()[m
[32m+[m[32m        processing_msg.edit_text = AsyncMock()[m
[32m+[m[32m        mock_update.message.reply_text.return_value = processing_msg[m
[32m+[m
[32m+[m[32m        result = await handle_voice_message(mock_update, mock_context)[m
[32m+[m
[32m+[m[32m        assert result == ConversationHandler.END[m
[32m+[m[32m        mock_context.bot.get_file.assert_called_once_with("audio_file_id")[m
[32m+[m[32m        mock_file.download_to_drive.assert_called_once()[m
[32m+[m[32m        mock_send_api.assert_called_once()[m
[32m+[m[32m        assert user_id not in active_sessions[m
[32m+[m
 [m
 if __name__ == '__main__':[m
[31m-    pytest.main([__file__])[m
\ No newline at end of file[m
[32m+[m[32m    pytest.main([__file__])[m
